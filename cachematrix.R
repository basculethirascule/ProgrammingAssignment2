#makeCacheMatrix: This function creates a special "matrix" object (i.e. a list) that can cache its inverse.
#cacheSolve: This function computes the inverse of the special "matrix" returned by makeCacheMatrix above.
#If the inverse has already been calculated (and the matrix has not changed), then cacheSolve should
#retrieve the inverse from the cache. Computing the inverse of a square matrix can be done with the solve
#function in R. For example, if X is a square invertible matrix, then solve(X) returns its inverse.



#makeCacheMatrix creates a special "matrix" object, which is really a list containing a function to
#1. set the value of the matrix
#2. get the value of the matrix
#3. set the value of the inverse matrix
#4. get the value of the inverse matrix

makeCacheMatrix <- function(x = matrix()) { # x is a matrix
        m <- NULL #m is an empty vector before the first call of function cacheSolve
        set <- function(y) { #The set function allows you to change the data within the special "matrix" object.
                x <<- y #the matrix value
                m <<- NULL #the inverse matrix value
        }
       
        get <- function() x #The get function allows you to retrieve the data (i.e. matrix) from the special "matrix" object.
        
        #The setinverse and getinverse functions are called by the cacheSolve function.
        setinverse <- function(solve) m <<- solve
        getinverse <- function() m
        list(set = set, get = get,
             setinverse = setinverse,
             getinverse = getinverse)
}


#The following function calculates the inverse of the special "matrix" object (x) created with the above
#function. However, it first checks to see if the inverse has already been calculated. If so,
#it gets the inverse from the cache and skips the computation. Otherwise, it calculates the
#inverse of the matrix and sets the value of the inverse in the cache via the setinverse function.

cacheSolve <- function(x, ...) { # x is the matrix
        m <- x$getinverse() #get the value of the inverse matrix from the cache 
        if(!is.null(m)) { #if the inverse matrix has been assigned to the cache...
                message("getting cached data")
                return(m) #return the inverse matrix
        }
        data <- x$get() #assign the matrix (x) from the special "matrix" object to data
        m <- solve(data, ...) #calculate the inverse matrix of data and assign to m
        x$setinverse(m) #assign the inverse matrix to the special "matrix" object generated by makeCacheMatrix
        m #autoprint the inverse matrix to the screen
}


mat <- makeCacheMatrix(matrix(1:4, 2, 2)) #create a special "matrix" object containing the matrix using function makeCacheMatrix()

cacheSolve(mat) #first run...
#     [,1] [,2]
#[1,]   -2  1.5
#[2,]    1 -0.5

cacheSolve(mat) #second run...
#getting cached data
#     [,1] [,2]
#[1,]   -2  1.5
#[2,]    1 -0.5










############################################################################

#Explanation of what should be happening if functions work correctly...
attributes(mat) #check which attributes are assigned to the special matrix
#$names
#[1] "set"        "get"        "setinverse" "getinverse"

mat$get() #call the matrix from the special "matrix" object
#     [,1] [,2]
#[1,]    1    3
#[2,]    2    4

solve(mat$get()) #calculate the inverse matrix to check the output you should get when you run cacheSolve...
#     [,1] [,2]
#[1,]   -2  1.5
#[2,]    1 -0.5

#If you have got the correct inverse matrix, when you multiply mat$get() by solve(mat$get(), you should get the identity matrix
mat$get() %*% solve(mat$get())
#     [,1] [,2]
#[1,]    1    0
#[2,]    0    1